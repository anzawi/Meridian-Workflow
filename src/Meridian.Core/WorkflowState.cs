namespace Meridian.Core;

using Enums;
using Extensions;
using Interfaces;

/// <summary>
/// Represents a state in a workflow, designed to hold state-specific information and define
/// the actions and hooks associated with the state.
/// </summary>
/// <typeparam name="TData">
/// The type of data associated with the workflow, constrained to implement <see cref="IWorkflowData"/>.
/// </typeparam>
public class WorkflowState<TData> where TData : class, IWorkflowData
{
    /// <summary>
    /// Represents the internal state type of the workflow state.
    /// Determines the specific category or condition of the state, such as Start, Normal, Completed, Cancelled, or Rejected.
    /// </summary>
    /// <remarks>
    /// This property is privately set and utilized internally within the workflow state to designate its current operational type.
    /// It defaults to <see cref="StateType.Normal"/> and can be updated through various workflow methods such as IsCompleted, IsStarted, etc.
    /// </remarks>
    private StateType StateType { get; set; } = StateType.Normal;

    /// <summary>
    /// Gets or sets the name of the workflow state.
    /// This property is used to identify and label the current state within a workflow.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Gets the Code for the workflow state, which is derived from the state name.
    /// The value is generated by converting the property <see cref="Name" /> into PascalCase format.
    /// </summary>
    /// <remarks>
    /// The Code property provides a standardized representation of the state by transforming
    /// the <see cref="Name" /> property into PascalCase using the provided string extension method.
    /// This property is read-only and dynamically computed.
    /// </remarks>
    public string Code => this.Name.ToPascalCase();

    /// <summary>
    /// Represents the collection of workflow actions associated with a specific workflow state.
    /// Each action defines a possible operation in the workflow, with associated transitions,
    /// conditions, and user or role assignments.
    /// </summary>
    /// <remarks>
    /// Actions allow for defining the behavior of a workflow state, such as transitioning to
    /// another state or executing specific logic based on conditions. An action can be auto-triggered,
    /// validated, and assigned to specific users, roles, or groups.
    /// </remarks>
    public List<WorkflowAction<TData>> Actions { get; set; } = [];

    /// <summary>
    /// A collection of hooks to be executed when entering a specific workflow state.
    /// </summary>
    /// <remarks>
    /// The <c>OnEnterHooks</c> property contains a list of descriptors representing
    /// actions or processes to be triggered upon transitioning into the associated state.
    /// These hooks allow customizing the behavior and side effects of the workflow
    /// during state entry.
    /// </remarks>
    /// <typeparam name="TData">
    /// The type of the workflow data associated with the state; must implement the <c>IWorkflowData</c> interface.
    /// </typeparam>
    public List<WorkflowHookDescriptor<TData>> OnEnterHooks { get; set; } = [];

    /// <summary>
    /// Represents a collection of hooks to be executed when exiting a workflow state.
    /// </summary>
    /// <typeparam name="TData">
    /// The type of data associated with the workflow, which implements the <see cref="IWorkflowData"/> interface.
    /// </typeparam>
    /// <remarks>
    /// The hooks stored in this property are triggered when the state is exited. The behavior of these hooks
    /// is defined by their respective <see cref="WorkflowHookDescriptor{TData}"/> instances.
    /// </remarks>
    public List<WorkflowHookDescriptor<TData>> OnExitHooks { get; set; } = [];

    /// <summary>
    /// Gets the type of the workflow state represented by the <see cref="Enums.StateType"/> enumeration.
    /// StateType can indicate whether the state is Start, Normal, Completed, Cancelled, or Rejected.
    /// </summary>
    /// <value>
    /// A value of type <see cref="Enums.StateType"/> that specifies the current type of the workflow state.
    /// </value>
    public StateType Type => this.StateType;

    /// <summary>
    /// Sets the current workflow state to "Completed".
    /// </summary>
    /// <returns>
    /// The updated workflow state instance with its type set to "Completed".
    /// </returns>
    public WorkflowState<TData> IsCompleted()
    {
        this.StateType = StateType.Completed;
        return this;
    }

    /// Sets the state type of the workflow to "Start" indicating that the state is the starting point of the workflow.
    /// <return>
    /// The current instance of WorkflowState with its state type set to "Start".
    /// </return>
    public WorkflowState<TData> IsStarted()
    {
        this.StateType = StateType.Start;
        return this;
    }

    /// <summary>
    /// Sets the state type to "Rejected" for the workflow state and returns the updated state.
    /// </summary>
    /// <returns>The current instance of <see cref="WorkflowState{TData}"/> updated with a "Rejected" state type.</returns>
    public WorkflowState<TData> IsRejected()
    {
        this.StateType = StateType.Rejected;
        return this;
    }

    /// <summary>
    /// Marks the workflow state as cancelled by updating the underlying state type to <see cref="StateType.Cancelled"/>.
    /// </summary>
    /// <returns>The current instance of <see cref="WorkflowState{TData}"/>.</returns>
    public WorkflowState<TData> IsCancelled()
    {
        this.StateType = StateType.Cancelled;
        return this;
    }

    /// <summary>
    /// Defines a new workflow action with the specified name, next state, optional automation flag,
    /// and an optional condition for execution.
    /// </summary>
    /// <param name="name">The name of the action to be added.</param>
    /// <param name="nextState">The name of the next workflow state after the action is executed.</param>
    /// <param name="isAuto">Indicates whether the action is automatic. Defaults to false.</param>
    /// <param name="condition">An optional condition function of type <c>Func&lt;TData, bool&gt;</c> that determines whether the action can be executed.</param>
    /// <returns>Returns the current <c>WorkflowState&lt;TData&gt;</c> instance with the added action.</returns>
    public WorkflowState<TData> Action(string name, string nextState, bool isAuto = false,
        Func<TData, bool>? condition = null)
    {
        if (this.Actions.Any(a => a.Name == name))
            return this;

        var action = new WorkflowAction<TData>
        {
            Name = name,
            NextState = nextState,
            IsAuto = isAuto,
            Condition = condition
        };
        this.Actions.Add(action);
        return this;
    }

    /// <summary>
    /// Configures and adds a new action to the workflow state.
    /// </summary>
    /// <param name="name">The name of the action to be added.</param>
    /// <param name="nextState">The name of the next state the workflow transitions to upon successful execution of the action.</param>
    /// <param name="config">An action to configure the <see cref="WorkflowAction{TData}"/> instance being added.</param>
    /// <param name="isAuto">Indicates whether the action is executed automatically without manual intervention. Defaults to false.</param>
    /// <param name="condition">An optional condition that determines whether the action can be executed based on the workflow data.</param>
    /// <returns>Returns the modified <see cref="WorkflowState{TData}"/> instance after the action has been added.</returns>
    public WorkflowState<TData> Action(string name, string nextState, Action<WorkflowAction<TData>> config,
        bool isAuto = false,
        Func<TData, bool>? condition = null)
    {
        var action = new WorkflowAction<TData>
        {
            Name = name,
            NextState = nextState,
            IsAuto = isAuto,
            Condition = condition
        };
        config(action);
        this.Actions.Add(action);
        return this;
    }
}