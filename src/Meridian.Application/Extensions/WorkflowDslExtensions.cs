namespace Meridian.Application.Extensions;

using Core.Dtos;
using Core.Interfaces;
using Core.Models;

/// <summary>
/// Provides extension methods to enhance the functionality of workflow elements,
/// such as workflow actions, states, and definitions, by allowing the addition of hooks,
/// validation, and other behavioral modifications in a DSL (Domain-Specific Language)-style manner.
/// </summary>
public static class WorkflowDslExtensions
{

    /// <summary>
    /// Prints the details of the workflow definition to the console for debugging purposes.
    /// This method should not be used in production environments and is intended only for development.
    /// </summary>
    /// <typeparam name="TData">The type of the workflow data associated with this workflow definition.</typeparam>
    /// <param name="def">The workflow definition to be printed to the console.</param>
    public static void PrintToConsole<TData>(this WorkflowDefinition<TData> def)
        where TData : class, IWorkflowData
    {
        const int defaultWidth = 70;
        var separator = new string('═', defaultWidth);

        Console.ForegroundColor = ConsoleColor.DarkRed;
        Console.WriteLine(separator);
        Console.WriteLine("This output is generated by 'PrintToConsole'!");
        Console.WriteLine("⚠ Do NOT use this in production. This is for development purposes only.");
        Console.WriteLine(separator);
        Console.ResetColor();

        Console.ForegroundColor = ConsoleColor.Yellow;
        Console.WriteLine($"Workflow: {def.Name}");
        Console.WriteLine(separator + "\n");
        Console.ResetColor();

        PrintHookGroup("On Request Created Hooks", def.OnCreateHooks);
        PrintHookGroup("On Request Transition Hooks", def.OnTransitionHooks);
        Console.WriteLine();

        foreach (var state in def.States)
        {
            var lines = new List<string>
            {
                "\x1b[1;36mState: " + state.Name + "\x1b[0m", // Cyan
            };


            if (state.OnEnterHooks.Count != 0 || state.OnExitHooks.Count != 0)
            {
                lines.Add("Hooks:");
                if (state.OnEnterHooks.Count != 0)
                    lines.Add($"  ⮡ OnEnter: {FormatHookList(state.OnEnterHooks)}");
                if (state.OnExitHooks.Count != 0)
                    lines.Add($"  ⮡ OnExit:  {FormatHookList(state.OnExitHooks)}");
            }

            if (state.Actions.Count == 0)
            {
                Console.ForegroundColor = ConsoleColor.DarkGray;
                lines.Add("• No actions");
                Console.ResetColor();
            }
            else
            {
                foreach (var action in state.Actions)
                {
                    lines.Add($"\x1b[1;32m• Action: {action.Name}\x1b[0m"); // Green

                    if (action.IsAuto)
                        lines.Add($"   ⮡ Auto Condition: {action.Condition}");

                    if (action.ValidateInput != null)
                        lines.Add($"   ⮡ Custom Validation: ENABLED");

                    if (action.UseAutomaticValidation)
                        lines.Add($"   ⮡ Auto Validation: ENABLED");

                    lines.Add($"   ⮡ Next State → {action.NextState}");

                    if (action.AssignedUsers.Count != 0 || action.AssignedRoles.Count != 0 ||
                        action.AssignedGroups.Count != 0)
                    {
                        lines.Add("   ⮡ Assigned To:");
                        if (action.AssignedUsers.Count != 0)
                            lines.Add($"      • Users:  {string.Join(", ", action.AssignedUsers)}");
                        if (action.AssignedRoles.Count != 0)
                            lines.Add($"      • Roles:  {string.Join(", ", action.AssignedRoles)}");
                        if (action.AssignedGroups.Count != 0)
                            lines.Add($"      • Groups: {string.Join(", ", action.AssignedGroups)}");
                    }

                    if (action.OnExecuteHooks.Count != 0)
                        lines.Add($"   ⮡ OnExecute Hooks: {FormatHookList(action.OnExecuteHooks)}");

                    lines.Add(""); // spacing
                }
            }

            var boxWidth = Math.Max(defaultWidth, lines.Max(line => StripAnsi(line).Length) + 4);
            var border = new string('─', boxWidth);

            Console.ForegroundColor = ConsoleColor.Gray;
            Console.WriteLine($"╭{border}╮");
            foreach (var line in lines)
            {
                Console.WriteLine($"│ {PadAnsi(line, boxWidth - 2)} │");
            }

            Console.WriteLine($"╰{border}╯\n");
            Console.ResetColor();
        }

        return;

        void PrintHookGroup(string title, List<WorkflowHookDescriptor<TData>> hooks)
        {
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine($"{title}:");
            Console.ResetColor();

            if (hooks.Count == 0)
            {
                Console.ForegroundColor = ConsoleColor.DarkGray;
                Console.WriteLine("  ⮡ None");
                Console.ResetColor();
            }
            else
            {
                foreach (var hook in hooks)
                {
                    Console.ForegroundColor = ConsoleColor.White;
                    Console.WriteLine($"  ⮡ {hook.Hook.GetType().Name}");
                    Console.ResetColor();
                }
            }

            Console.WriteLine(); // spacing
        }

        string FormatHookList(IEnumerable<WorkflowHookDescriptor<TData>> hooks) =>
            $"[{string.Join(", ", hooks.Select(h => h.Hook.GetType().Name))}]";

        string StripAnsi(string input)
        {
            return System.Text.RegularExpressions.Regex.Replace(input, @"\x1B\[[0-9;]*[mGKF]", "");
        }

        string PadAnsi(string input, int totalWidth)
        {
            var plain = StripAnsi(input);
            var padRight = totalWidth - plain.Length;
            return input + new string(' ', Math.Max(0, padRight));
        }
    }
}